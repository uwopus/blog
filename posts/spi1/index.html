<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>Main Board and Pico Communications - Opus Build Blog: Autonomous Mural Painting Robot</title><meta name=description content="January 14th, 2022
This week we&rsquo;ve been waiting for our Talon SRX Motor Controllers generously lended from Team 1325. While we wait for them to get here from Mississauga, we decided to get the Pico board in a position where we can plug in the motor controllers as soon as they arrive and begin turning them.
We chose SPI as the communication protocol between the Raspberry Pi Zero control computer and the Raspberry Pi Pico microcontroller because the UART port was left open as a slot for the IMU and I2C doesn&rsquo;t work particularly well over longer cable runs because of the open-drain drivers."><meta name=author content><link rel="preload stylesheet" as=style href=https://uwopus.github.io/blog/app.min.css><link rel="preload stylesheet" as=style href=https://uwopus.github.io/blog/an-old-hope.min.css><script defer src=https://uwopus.github.io/blog/highlight.min.js onload=hljs.initHighlightingOnLoad()></script><link rel=preload as=image href=https://uwopus.github.io/blog/theme.png><link rel=icon href=https://uwopus.github.io/blog/favicon.ico><link rel=apple-touch-icon href=https://uwopus.github.io/blog/apple-touch-icon.png><meta name=generator content="Hugo 0.85.0"><meta property="og:title" content="Main Board and Pico Communications"><meta property="og:description" content="January 14th, 2022
This week we&rsquo;ve been waiting for our Talon SRX Motor Controllers generously lended from Team 1325. While we wait for them to get here from Mississauga, we decided to get the Pico board in a position where we can plug in the motor controllers as soon as they arrive and begin turning them.
We chose SPI as the communication protocol between the Raspberry Pi Zero control computer and the Raspberry Pi Pico microcontroller because the UART port was left open as a slot for the IMU and I2C doesn&rsquo;t work particularly well over longer cable runs because of the open-drain drivers."><meta property="og:type" content="article"><meta property="og:url" content="https://uwopus.github.io/blog/posts/spi1/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-01-14T20:15:51-05:00"><meta property="article:modified_time" content="2022-01-14T20:15:51-05:00"><meta itemprop=name content="Main Board and Pico Communications"><meta itemprop=description content="January 14th, 2022
This week we&rsquo;ve been waiting for our Talon SRX Motor Controllers generously lended from Team 1325. While we wait for them to get here from Mississauga, we decided to get the Pico board in a position where we can plug in the motor controllers as soon as they arrive and begin turning them.
We chose SPI as the communication protocol between the Raspberry Pi Zero control computer and the Raspberry Pi Pico microcontroller because the UART port was left open as a slot for the IMU and I2C doesn&rsquo;t work particularly well over longer cable runs because of the open-drain drivers."><meta itemprop=datePublished content="2022-01-14T20:15:51-05:00"><meta itemprop=dateModified content="2022-01-14T20:15:51-05:00"><meta itemprop=wordCount content="511"><meta itemprop=keywords content><meta name=twitter:card content="summary"><meta name=twitter:title content="Main Board and Pico Communications"><meta name=twitter:description content="January 14th, 2022
This week we&rsquo;ve been waiting for our Talon SRX Motor Controllers generously lended from Team 1325. While we wait for them to get here from Mississauga, we decided to get the Pico board in a position where we can plug in the motor controllers as soon as they arrive and begin turning them.
We chose SPI as the communication protocol between the Raspberry Pi Zero control computer and the Raspberry Pi Pico microcontroller because the UART port was left open as a slot for the IMU and I2C doesn&rsquo;t work particularly well over longer cable runs because of the open-drain drivers."></head><body class=not-ready data-menu=false><header class=header><p class=logo><a class=site-name href=https://uwopus.github.io/blog/>Opus Build Blog: Autonomous Mural Painting Robot</a><a class=btn-dark></a></p><script>let bodyClx=document.body.classList,btnDark=document.querySelector('.btn-dark'),sysDark=window.matchMedia('(prefers-color-scheme: dark)'),darkVal=localStorage.getItem('dark'),setDark=a=>{bodyClx[a?'add':'remove']('dark'),localStorage.setItem('dark',a?'yes':'no')};setDark(darkVal?darkVal==='yes':sysDark.matches),requestAnimationFrame(()=>bodyClx.remove('not-ready')),btnDark.addEventListener('click',()=>setDark(!bodyClx.contains('dark'))),sysDark.addEventListener('change',a=>setDark(a.matches))</script></header><main class=main><article class=post-single><header class=post-title><p><time>:date_medium</time></p><h1>Main Board and Pico Communications</h1></header><section class=post-content><p>January 14th, 2022</p><p>This week we&rsquo;ve been waiting for our Talon SRX Motor Controllers generously lended from Team 1325. While we wait for them to get here from Mississauga, we decided to get the Pico board in a position where we can plug in the motor controllers as soon as they arrive and begin turning them.</p><p>We chose SPI as the communication protocol between the Raspberry Pi Zero control computer and the Raspberry Pi Pico microcontroller because the UART port was left open as a slot for the IMU and I2C doesn&rsquo;t work particularly well over longer cable runs because of the open-drain drivers. We were thinking that it would be fairly simple to get the two devices talking over SPI because its such a common protocol.</p><p>When actually jumping into the code, we discovered that the C++ SDK library functions for the SPI are <em>blocking</em>, which is extremely disadvantageous. This means that execution would be completely paused while sending or receiving bytes. This is a problem in terms of safety because the Pico would not be able to stop the motors if communication was lost in the event of a wire break or Zero crash without the use of the second core or watchdog timer logic.</p><p>The packets look like:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>#define MAX_PKT_SIZE 10
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>enum</span> packet_types {
    INIT <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, 
    HEARTBEAT <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>,
    STATE <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>, 
    PWM <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>, 
    ENC <span style=color:#f92672>=</span> <span style=color:#ae81ff>4</span>
} opus_packet_type_t;

<span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> packet {
    <span style=color:#66d9ef>uint32_t</span> t_ms; <span style=color:#75715e>// sequence number, monotonically increasing until wraparound 
</span><span style=color:#75715e></span>    opus_packet_type_t type;
    <span style=color:#66d9ef>uint8_t</span> len;
    <span style=color:#66d9ef>uint8_t</span> data[MAX_PKT_SIZE];
} opus_packet_t;
</code></pre></div><h1 id=attempt-1-interrupts>Attempt 1: Interrupts</h1><p>The first attempt to solve this problem involved setting up the <code>RXIM</code> interrupt in the Primecell SPI peripheral on the Pico. The overall idea behind this was:</p><ol><li>Processor is doing normal tasks</li><li>Data is sent through the SPI bus to the Pico, which is the slave</li><li>Once the Receive FIFO is more than half full, the SPI peripheral would raise the <code>RXIM</code> interrupt, which would be masked to one of the NVIC processor interrupts</li><li>An ISR would toggle a flag to indicate data was available</li><li>The main program thread would then read the data from the receive FIFO until it was empty.</li></ol><p>This approach proved to be quite problematic because the timing would have to be fairly precise to ensure that the recieve buffer did not fill up. Also, the logic was frustrating to implement. Therefore, we decided to try attempt number two.</p><h1 id=attempt-2-dma>Attempt 2: DMA</h1><p>Direct Memory Access was then attempted. This approach involved setting up the Pico&rsquo;s DMA controller to transfer data from the SPI peripheral&rsquo;s recieve buffer to a section in memory directly, without the CPU&rsquo;s intervention. The overall process flow behind this is:</p><ol><li>Configure DMA to transfer the number of bytes that is required</li><li>Processor does normal tasks</li><li>When DMA has transferred <code>sizeof(opus_packet_t)</code> bytes, it will raise an interrupt</li><li>Processor reads the data, performs the appropriate action, and sends a response back</li><li>Processor clears the interrupt and re-enables DMA, returning to normal tasks</li></ol><p>This methodology worked! We were able to transfer packets that were legible from both sides.</p></section><nav class=post-nav><a class=prev href=https://uwopus.github.io/blog/posts/webapp/><span>←</span><span>Web App Design</span></a>
<a class=next href=https://uwopus.github.io/blog/posts/zero-bringup/><span>Raspberry Pi Zero Bringup</span><span>→</span></a></nav></article></main><footer class=footer><p>&copy; 2022 <a href=https://uwopus.github.io/blog/>Opus Build Blog: Autonomous Mural Painting Robot</a></p><p>Powered by <a href=https://gohugo.io/ rel=noopener target=_blank>Hugo️️</a>️</p><p><a href=https://github.com/nanxiaobei/hugo-paper rel=noopener target=_blank>Paper 5.1</a></p></footer></body></html>
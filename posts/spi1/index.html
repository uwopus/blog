<!doctype html><html class="not-ready lg:text-base" style=--bg:#faf8f1 lang=en-us>
<head>
<meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<title>Main Board and Pico Communications - Opus Build Blog: Autonomous Wall Plotting Robot</title><meta name=theme-color>
<meta name=description content="This week we&rsquo;ve been waiting for our Talon SRX Motor Controllers generously lended from Team 1325. While we wait for them to get here from Mississauga, we decided to get the Pico board in a position where we can plug in the motor controllers as soon as they arrive and begin turning them.
We chose SPI as the communication protocol between the Raspberry Pi Zero control computer and the Raspberry Pi Pico microcontroller because the UART port was left open as a slot for the IMU and I2C doesn&rsquo;t work particularly well over longer cable runs because of the open-drain drivers.">
<meta name=author content="Opus Build Blog: Autonomous Wall Plotting Robot">
<link rel="preload stylesheet" as=style href=https://uwopus.github.io/blog/main.min.css>
<link rel=preload as=image href=https://uwopus.github.io/blog/theme.png>
<script defer src=https://uwopus.github.io/blog/highlight.min.js onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://uwopus.github.io/blog/favicon.ico>
<link rel=apple-touch-icon href=https://uwopus.github.io/blog/apple-touch-icon.png>
<meta name=generator content="Hugo 0.93.3">
<meta itemprop=name content="Main Board and Pico Communications">
<meta itemprop=description content="This week we&rsquo;ve been waiting for our Talon SRX Motor Controllers generously lended from Team 1325. While we wait for them to get here from Mississauga, we decided to get the Pico board in a position where we can plug in the motor controllers as soon as they arrive and begin turning them.
We chose SPI as the communication protocol between the Raspberry Pi Zero control computer and the Raspberry Pi Pico microcontroller because the UART port was left open as a slot for the IMU and I2C doesn&rsquo;t work particularly well over longer cable runs because of the open-drain drivers."><meta itemprop=datePublished content="2022-01-18T20:15:51-05:00">
<meta itemprop=dateModified content="2022-01-18T20:15:51-05:00">
<meta itemprop=wordCount content="534">
<meta itemprop=keywords content>
<meta property="og:title" content="Main Board and Pico Communications">
<meta property="og:description" content="This week we&rsquo;ve been waiting for our Talon SRX Motor Controllers generously lended from Team 1325. While we wait for them to get here from Mississauga, we decided to get the Pico board in a position where we can plug in the motor controllers as soon as they arrive and begin turning them.
We chose SPI as the communication protocol between the Raspberry Pi Zero control computer and the Raspberry Pi Pico microcontroller because the UART port was left open as a slot for the IMU and I2C doesn&rsquo;t work particularly well over longer cable runs because of the open-drain drivers.">
<meta property="og:type" content="article">
<meta property="og:url" content="https://uwopus.github.io/blog/posts/spi1/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2022-01-18T20:15:51-05:00">
<meta property="article:modified_time" content="2022-01-18T20:15:51-05:00">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="Main Board and Pico Communications">
<meta name=twitter:description content="This week we&rsquo;ve been waiting for our Talon SRX Motor Controllers generously lended from Team 1325. While we wait for them to get here from Mississauga, we decided to get the Pico board in a position where we can plug in the motor controllers as soon as they arrive and begin turning them.
We chose SPI as the communication protocol between the Raspberry Pi Zero control computer and the Raspberry Pi Pico microcontroller because the UART port was left open as a slot for the IMU and I2C doesn&rsquo;t work particularly well over longer cable runs because of the open-drain drivers.">
<link rel=canonical href=https://uwopus.github.io/blog/posts/spi1/>
</head><body class="text-black duration-200 ease-out dark:text-white">
<header class="mx-auto flex h-[4.5rem] max-w-3xl px-8 lg:justify-center">
<div class="relative z-50 mr-auto flex items-center">
<a class="-translate-x-[1px] -translate-y-[1px] text-2xl font-semibold" href=https://uwopus.github.io/blog/>Opus Build Blog: Autonomous Wall Plotting Robot</a>
<div class="btn-dark text-[0] ml-4 h-6 w-6 shrink-0 cursor-pointer [background:url(./theme.png)_left_center/_auto_theme('spacing.6')_no-repeat] [transition:_background-position_0.4s_steps(5)] dark:[background-position:right]" role=button aria-label=Dark></div></div><div class="btn-menu relative z-50 -mr-8 flex h-[4.5rem] w-[5rem] shrink-0 cursor-pointer flex-col items-center justify-center gap-2.5 lg:hidden" role=button aria-label=Menu></div><script>const htmlClass=document.documentElement.classList;setTimeout(()=>{htmlClass.remove("not-ready")},10);const btnMenu=document.querySelector(".btn-menu");btnMenu.addEventListener("click",()=>{htmlClass.toggle("open")});const metaTheme=document.querySelector('meta[name="theme-color"]'),lightBg="#faf8f1".replace(/"/g,''),setDark=e=>{metaTheme.setAttribute("content",e?"#000":lightBg),htmlClass[e?"add":"remove"]("dark"),localStorage.setItem("dark",e)},darkScheme=window.matchMedia("(prefers-color-scheme: dark)");if(htmlClass.contains("dark"))setDark(!0);else{const e=localStorage.getItem("dark");setDark(e?e==="true":darkScheme.matches)}darkScheme.addEventListener("change",e=>{setDark(e.matches)});const btnDark=document.querySelector(".btn-dark");btnDark.addEventListener("click",()=>{setDark(localStorage.getItem("dark")!=="true")})</script>
<div class="nav-wrapper fixed inset-x-0 top-full z-40 flex h-full select-none flex-col justify-center pb-16 duration-200 dark:bg-black lg:static lg:h-auto lg:flex-row lg:!bg-transparent lg:pb-0 lg:transition-none">
</div></header><main class="prose prose-neutral relative mx-auto min-h-[calc(100%-9rem)] max-w-3xl px-8 pb-16 pt-12 dark:prose-invert">
<article>
<header class=mb-16>
<h1 class="!my-0 pb-2.5">Main Board and Pico Communications</h1><div class="text-sm antialiased opacity-60">
<time>Jan 18, 2022</time>
</div></header><section><p>This week we&rsquo;ve been waiting for our Talon SRX Motor Controllers generously lended from Team 1325. While we wait for them to get here from Mississauga, we decided to get the Pico board in a position where we can plug in the motor controllers as soon as they arrive and begin turning them.</p><p>We chose SPI as the communication protocol between the Raspberry Pi Zero control computer and the Raspberry Pi Pico microcontroller because the UART port was left open as a slot for the IMU and I2C doesn&rsquo;t work particularly well over longer cable runs because of the open-drain drivers. We were thinking that it would be fairly simple to get the two devices talking over SPI because its such a common protocol.</p><p>When actually jumping into the code, we discovered that the C++ SDK library functions for the SPI are <em>blocking</em>, which is extremely disadvantageous. This means that execution would be completely paused while sending or receiving bytes. This is a problem in terms of safety because the Pico would not be able to stop the motors if communication was lost in the event of a wire break or Zero crash without the use of the second core or watchdog timer logic.</p><p>The packets look like:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#define MAX_PKT_SIZE 10
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>enum</span> packet_types {
</span></span><span style=display:flex><span>    INIT <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, 
</span></span><span style=display:flex><span>    HEARTBEAT <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span>    STATE <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>, 
</span></span><span style=display:flex><span>    PWM <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>, 
</span></span><span style=display:flex><span>    ENC <span style=color:#f92672>=</span> <span style=color:#ae81ff>4</span>
</span></span><span style=display:flex><span>} opus_packet_type_t;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> packet {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint32_t</span> t_ms; <span style=color:#75715e>// sequence number, monotonically increasing until wraparound 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    opus_packet_type_t type;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint8_t</span> len;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint8_t</span> data[MAX_PKT_SIZE];
</span></span><span style=display:flex><span>} opus_packet_t;
</span></span></code></pre></div><h1 id=attempt-1-interrupts>Attempt 1: Interrupts</h1><p>The first attempt to solve this problem involved setting up the <code>RXIM</code> interrupt in the Primecell SPI peripheral on the Pico. The overall idea behind this was:</p><ol>
<li>Processor is doing normal tasks</li><li>Data is sent through the SPI bus to the Pico, which is the slave</li><li>Once the Receive FIFO is more than half full, the SPI peripheral would raise the <code>RXIM</code> interrupt, which would be masked to one of the NVIC processor interrupts</li><li>An ISR would toggle a flag to indicate data was available</li><li>The main program thread would then read the data from the receive FIFO until it was empty.</li></ol><p>This approach proved to be quite problematic because the timing would have to be fairly precise to ensure that the recieve buffer did not fill up. Also, the logic was frustrating to implement. Therefore, we decided to try attempt number two.</p><h1 id=attempt-2-dma>Attempt 2: DMA</h1><p>Direct Memory Access was then attempted. This approach involved setting up the Pico&rsquo;s DMA controller to transfer data from the SPI peripheral&rsquo;s recieve buffer to a section in memory directly, without the CPU&rsquo;s intervention. The overall process flow behind this is:</p><ol>
<li>Configure DMA to transfer the number of bytes that is required</li><li>Processor does normal tasks</li><li>When DMA has transferred <code>sizeof(opus_packet_t)</code> bytes, it will raise an interrupt</li><li>Processor reads the data, performs the appropriate action, and sends a response back</li><li>Processor clears the interrupt and re-enables DMA, returning to normal tasks</li></ol><p>This methodology worked! We were able to transfer packets that were legible from both sides.</p><p>These attempts were recorded with a Saleae Logic Analyzer to debug issues that happened along the way. This is a photo of the communications working properly:</p><p><img src=/blog/images/spi1/saleaeComms.png alt=SPIComms></p></section><nav class="mt-24 flex rounded-lg bg-black/[3%] text-lg dark:bg-white/[8%]">
<a class="flex w-1/2 items-center rounded-l-md p-6 pr-3 font-semibold no-underline hover:bg-black/[2%] dark:hover:bg-white/[3%]" href=https://uwopus.github.io/blog/posts/webapp/><span class=mr-1.5>←</span><span>Web App Design</span></a>
<a class="ml-auto flex w-1/2 items-center justify-end rounded-r-md p-6 pl-3 font-semibold no-underline hover:bg-black/[2%] dark:hover:bg-white/[3%]" href=https://uwopus.github.io/blog/posts/picobringup/><span>Raspberry Pi Pico Bringup</span><span class=ml-1.5>→</span></a>
</nav></article></main><footer class="opaco mx-auto flex h-[4.5rem] max-w-3xl items-center px-8 text-[0.9em] opacity-60">
<div class=mr-auto>
&copy; 2024
<a class=link href=https://uwopus.github.io/blog/>Opus Build Blog: Autonomous Wall Plotting Robot</a>
</div><a class="link mx-6" href=https://gohugo.io/ rel=noopener target=_blank>Powered by Hugo️️</a>️
<a class=link href=https://github.com/nanxiaobei/hugo-paper rel=noopener target=_blank>✎ Paper</a>
</footer></body></html>